import{r as p,n as Tt}from"./index-940c8f2e.js";var Pt={exports:{}},Ut={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var G=p;function Zt(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var te=typeof Object.is=="function"?Object.is:Zt,ee=G.useState,ne=G.useEffect,se=G.useLayoutEffect,re=G.useDebugValue;function oe(t,e){var n=e(),r=ee({inst:{value:n,getSnapshot:e}}),s=r[0].inst,o=r[1];return se(function(){s.value=n,s.getSnapshot=e,lt(s)&&o({inst:s})},[t,n,e]),ne(function(){return lt(s)&&o({inst:s}),t(function(){lt(s)&&o({inst:s})})},[t]),re(n),n}function lt(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!te(t,n)}catch{return!0}}function ie(t,e){return e()}var ae=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?ie:oe;Ut.useSyncExternalStore=G.useSyncExternalStore!==void 0?G.useSyncExternalStore:ae;Pt.exports=Ut;var ce=Pt.exports;const P=()=>{},D=P(),ft=Object,a=t=>t===D,N=t=>typeof t=="function",U=(t,e)=>({...t,...e}),ue=t=>N(t.then),rt=new WeakMap;let le=0;const Z=t=>{const e=typeof t,n=t&&t.constructor,r=n==Date;let s,o;if(ft(t)===t&&!r&&n!=RegExp){if(s=rt.get(t),s)return s;if(s=++le+"~",rt.set(t,s),n==Array){for(s="@",o=0;o<t.length;o++)s+=Z(t[o])+",";rt.set(t,s)}if(n==ft){s="#";const c=ft.keys(t).sort();for(;!a(o=c.pop());)a(t[o])||(s+=o+":"+Z(t[o])+",");rt.set(t,s)}}else s=r?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s},W=new WeakMap,dt={},ot={},wt="undefined",it=typeof window!=wt,vt=typeof document!=wt,fe=()=>it&&typeof window.requestAnimationFrame!=wt,qt=(t,e)=>{const n=W.get(t);return[()=>!a(e)&&t.get(e)||dt,r=>{if(!a(e)){const s=t.get(e);e in ot||(ot[e]=s),n[5](e,U(s,r),s||dt)}},n[6],()=>!a(e)&&e in ot?ot[e]:!a(e)&&t.get(e)||dt]};let St=!0;const de=()=>St,[_t,pt]=it&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[P,P],Ee=()=>{const t=vt&&document.visibilityState;return a(t)||t!=="hidden"},Re=t=>(vt&&document.addEventListener("visibilitychange",t),_t("focus",t),()=>{vt&&document.removeEventListener("visibilitychange",t),pt("focus",t)}),he=t=>{const e=()=>{St=!0,t()},n=()=>{St=!1};return _t("online",e),_t("offline",n),()=>{pt("online",e),pt("offline",n)}},ve={isOnline:de,isVisible:Ee},Se={initFocus:Re,initReconnect:he},xt=!Tt.useId,tt=!it||"Deno"in window,_e=t=>fe()?window.requestAnimationFrame(t):setTimeout(t,1),Et=tt?p.useEffect:p.useLayoutEffect,Rt=typeof navigator<"u"&&navigator.connection,Ft=!tt&&Rt&&(["slow-2g","2g"].includes(Rt.effectiveType)||Rt.saveData),gt=t=>{if(N(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?Z(t):"",[t,e]};let pe=0;const mt=()=>++pe,Ht=0,jt=1,kt=2,me=3;var Q={__proto__:null,ERROR_REVALIDATE_EVENT:me,FOCUS_EVENT:Ht,MUTATE_EVENT:kt,RECONNECT_EVENT:jt};async function $t(...t){const[e,n,r,s]=t,o=U({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let c=o.populateCache;const R=o.rollbackOnError;let d=o.optimisticData;const A=g=>typeof R=="function"?R(g):R!==!1,m=o.throwOnError;if(N(n)){const g=n,h=[],I=e.keys();for(const S of I)!/^\$(inf|sub)\$/.test(S)&&g(e.get(S)._k)&&h.push(S);return Promise.all(h.map(v))}return v(n);async function v(g){const[h]=gt(g);if(!h)return;const[I,S]=qt(e,h),[at,i,et,Y]=W.get(e),M=()=>{const V=at[h];return(N(o.revalidate)?o.revalidate(I().data,g):o.revalidate!==!1)&&(delete et[h],delete Y[h],V&&V[0])?V[0](kt).then(()=>I().data):I().data};if(t.length<3)return M();let T=r,C;const H=mt();i[h]=[H,0];const E=!a(d),j=I(),y=j.data,k=j._c,q=a(k)?y:k;if(E&&(d=N(d)?d(q,y):d,S({data:d,_c:q})),N(T))try{T=T(q)}catch(V){C=V}if(T&&ue(T))if(T=await T.catch(V=>{C=V}),H!==i[h][0]){if(C)throw C;return T}else C&&E&&A(C)&&(c=!0,S({data:q,_c:D}));if(c&&!C)if(N(c)){const V=c(T,q);S({data:V,error:D,_c:D})}else S({data:T,error:D,_c:D});if(i[h][1]=mt(),Promise.resolve(M()).then(()=>{S({_c:D})}),C){if(m)throw C;return}return T}}const Wt=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},Te=(t,e)=>{if(!W.has(t)){const n=U(Se,e),r={},s=$t.bind(D,t);let o=P;const c={},R=(m,v)=>{const g=c[m]||[];return c[m]=g,g.push(v),()=>g.splice(g.indexOf(v),1)},d=(m,v,g)=>{t.set(m,v);const h=c[m];if(h)for(const I of h)I(v,g)},A=()=>{if(!W.has(t)&&(W.set(t,[r,{},{},{},s,d,R]),!tt)){const m=n.initFocus(setTimeout.bind(D,Wt.bind(D,r,Ht))),v=n.initReconnect(setTimeout.bind(D,Wt.bind(D,r,jt)));o=()=>{m&&m(),v&&v(),W.delete(t)}}};return A(),[t,s,A,o]}return[t,W.get(t)[4]]},we=(t,e,n,r,s)=>{const o=n.errorRetryCount,c=s.retryCount,R=~~((Math.random()+.5)*(1<<(c<8?c:8)))*n.errorRetryInterval;!a(o)&&c>o||setTimeout(r,R,s)},ge=(t,e)=>Z(t)==Z(e),[zt,Oe]=Te(new Map),De=U({onLoadingSlow:P,onSuccess:P,onError:P,onErrorRetry:we,onDiscarded:P,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:Ft?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:Ft?5e3:3e3,compare:ge,isPaused:()=>!1,cache:zt,mutate:Oe,fallback:{}},ve),Ce=(t,e)=>{const n=U(t,e);if(e){const{use:r,fallback:s}=t,{use:o,fallback:c}=e;r&&o&&(n.use=r.concat(o)),s&&c&&(n.fallback=U(s,c))}return n},be=p.createContext({}),Ae="$inf$",Bt=it&&window.__SWR_DEVTOOLS_USE__,Ve=Bt?window.__SWR_DEVTOOLS_USE__:[],Ie=()=>{Bt&&(window.__SWR_DEVTOOLS_REACT__=Tt)},Jt=t=>N(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],ye=()=>U(De,p.useContext(be)),Le=t=>(e,n,r)=>t(e,n&&((...o)=>{const[c]=gt(e),[,,,R]=W.get(zt);if(c.startsWith(Ae))return n(...o);const d=R[c];return a(d)?n(...o):(delete R[c],d)}),r),Ne=Ve.concat(Le),xe=t=>function(...n){const r=ye(),[s,o,c]=Jt(n),R=Ce(r,c);let d=t;const{use:A}=R,m=(A||[]).concat(Ne);for(let v=m.length;v--;)d=m[v](d);return d(s,o||R.fetcher||null,R)},Fe=(t,e,n)=>{const r=e[t]||(e[t]=[]);return r.push(n),()=>{const s=r.indexOf(n);s>=0&&(r[s]=r[r.length-1],r.pop())}},We=(t,e)=>(...n)=>{const[r,s,o]=Jt(n),c=(o.use||[]).concat(e);return t(r,s,{...o,use:c})};Ie();const Mt=Tt.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)}),ht={dedupe:!0},Me=(t,e,n)=>{const{cache:r,compare:s,suspense:o,fallbackData:c,revalidateOnMount:R,revalidateIfStale:d,refreshInterval:A,refreshWhenHidden:m,refreshWhenOffline:v,keepPreviousData:g}=n,[h,I,S,at]=W.get(r),[i,et]=gt(t),Y=p.useRef(!1),M=p.useRef(!1),T=p.useRef(i),C=p.useRef(e),H=p.useRef(n),E=()=>H.current,j=()=>E().isVisible()&&E().isOnline(),[y,k,q,V]=qt(r,i),$=p.useRef({}).current,Kt=a(c)?n.fallback[i]:c,Ot=(u,l)=>{for(const w in $){const f=w;if(f==="data"){if(!s(u[f],l[f])&&(!a(u[f])||!s(st,l[f])))return!1}else if(l[f]!==u[f])return!1}return!0},Dt=p.useMemo(()=>{const u=(()=>!i||!e?!1:a(R)?E().isPaused()||o?!1:a(d)?!0:d:R)(),l=O=>{const x=U(O);return delete x._k,u?{isValidating:!0,isLoading:!0,...x}:x},w=y(),f=V(),L=l(w),K=w===f?L:l(f);let _=L;return[()=>{const O=l(y());return Ot(O,_)?(_.data=O.data,_.isLoading=O.isLoading,_.isValidating=O.isValidating,_.error=O.error,_):(_=O,O)},()=>K]},[r,i]),z=ce.useSyncExternalStore(p.useCallback(u=>q(i,(l,w)=>{Ot(w,l)||u()}),[r,i]),Dt[0],Dt[1]),Ct=!Y.current,Gt=h[i]&&h[i].length>0,B=z.data,J=a(B)?Kt:B,nt=z.error,bt=p.useRef(J),st=g?a(B)?bt.current:B:J,At=(()=>Gt&&!a(nt)?!1:Ct&&!a(R)?R:E().isPaused()?!1:o?a(J)?!1:d:a(J)||d)(),Vt=!!(i&&e&&Ct&&At),Yt=a(z.isValidating)?Vt:z.isValidating,Xt=a(z.isLoading)?Vt:z.isLoading,X=p.useCallback(async u=>{const l=C.current;if(!i||!l||M.current||E().isPaused())return!1;let w,f,L=!0;const K=u||{},_=!S[i]||!K.dedupe,O=()=>xt?!M.current&&i===T.current&&Y.current:i===T.current,x={isValidating:!1,isLoading:!1},yt=()=>{k(x)},Lt=()=>{const b=S[i];b&&b[1]===f&&delete S[i]},Nt={isValidating:!0};a(y().data)&&(Nt.isLoading=!0);try{if(_&&(k(Nt),n.loadingTimeout&&a(y().data)&&setTimeout(()=>{L&&O()&&E().onLoadingSlow(i,n)},n.loadingTimeout),S[i]=[l(et),mt()]),[w,f]=S[i],w=await w,_&&setTimeout(Lt,n.dedupingInterval),!S[i]||S[i][1]!==f)return _&&O()&&E().onDiscarded(i),!1;x.error=D;const b=I[i];if(!a(b)&&(f<=b[0]||f<=b[1]||b[1]===0))return yt(),_&&O()&&E().onDiscarded(i),!1;const F=y().data;x.data=s(F,w)?F:w,_&&O()&&E().onSuccess(w,i,n)}catch(b){Lt();const F=E(),{shouldRetryOnError:ct}=F;F.isPaused()||(x.error=b,_&&O()&&(F.onError(b,i,F),(ct===!0||N(ct)&&ct(b))&&(!E().revalidateOnFocus||!E().revalidateOnReconnect||j())&&F.onErrorRetry(b,i,F,Qt=>{const ut=h[i];ut&&ut[0]&&ut[0](Q.ERROR_REVALIDATE_EVENT,Qt)},{retryCount:(K.retryCount||0)+1,dedupe:!0})))}return L=!1,yt(),!0},[i,r]),It=p.useCallback((...u)=>$t(r,T.current,...u),[]);if(Et(()=>{C.current=e,H.current=n,a(B)||(bt.current=B)}),Et(()=>{if(!i)return;const u=X.bind(D,ht);let l=0;const f=Fe(i,h,(L,K={})=>{if(L==Q.FOCUS_EVENT){const _=Date.now();E().revalidateOnFocus&&_>l&&j()&&(l=_+E().focusThrottleInterval,u())}else if(L==Q.RECONNECT_EVENT)E().revalidateOnReconnect&&j()&&u();else{if(L==Q.MUTATE_EVENT)return X();if(L==Q.ERROR_REVALIDATE_EVENT)return X(K)}});return M.current=!1,T.current=i,Y.current=!0,k({_k:et}),At&&(a(J)||tt?u():_e(u)),()=>{M.current=!0,f()}},[i]),Et(()=>{let u;function l(){const f=N(A)?A(y().data):A;f&&u!==-1&&(u=setTimeout(w,f))}function w(){!y().error&&(m||E().isVisible())&&(v||E().isOnline())?X(ht).then(l):l()}return l(),()=>{u&&(clearTimeout(u),u=-1)}},[A,m,v,i]),p.useDebugValue(st),o&&a(J)&&i){if(!xt&&tt)throw new Error("Fallback data is required when using suspense in SSR.");C.current=e,H.current=n,M.current=!1;const u=at[i];if(!a(u)){const l=It(u);Mt(l)}if(a(nt)){const l=X(ht);a(st)||(l.status="fulfilled",l.value=!0),Mt(l)}else throw nt}return{mutate:It,get data(){return $.data=!0,st},get error(){return $.error=!0,nt},get isValidating(){return $.isValidating=!0,Yt},get isLoading(){return $.isLoading=!0,Xt}}},Pe=xe(Me),Ue=t=>(e,n,r)=>(r.revalidateOnFocus=!1,r.revalidateIfStale=!1,r.revalidateOnReconnect=!1,t(e,n,r)),He=We(Pe,Ue);export{He as u};
